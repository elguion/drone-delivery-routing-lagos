<!--
Filename: drone_floyd_warshall_unilag_lagos.html
Description: Responsive HTML page that visualizes a small Lagos delivery network (UNILAG, Akoka, Yaba, Surulere, Bariga, Ojuelegba, Gbagada).
- Runs Floyd-Warshall in JavaScript for interactive shortest-path queries
- Computes MST (Prim) for the network and draws it (thicker lines)
- Allows selecting any two nodes to compute/display shortest path and total distance
- Export path+distance as JSON to feed a drone

Also included below is a C++ implementation (floyd.cpp) which performs Floyd-Warshall on the same network and prints distance/path matrices. Use that as the base algorithm implementation for backend or embedded systems.
-->

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Drone Delivery — UNILAG Lagos Network (Floyd–Warshall + MST)</title>
  <style>
    :root{--bg:#0f172a;--card:#0b1220;--accent:#06b6d4;--muted:#9aa6b2;--white:#e6eef6}
    html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Roboto,Arial;color:var(--white);background:linear-gradient(180deg,#071129 0%, #0b1624 100%)}
    .app{display:flex;flex-direction:column;height:100vh;padding:1rem;gap:1rem}
    .top{display:flex;gap:1rem;align-items:center}
    h1{margin:0;font-size:1.15rem}
    .card{background:rgba(255,255,255,0.02);border-radius:10px;padding:1rem;box-shadow:0 6px 18px rgba(2,6,23,0.6)}
    .controls{min-width:300px}
    .map-wrap{flex:1;display:flex;align-items:stretch}
    svg{flex:1;border-radius:8px}
    label{display:block;font-size:0.8rem;color:var(--muted);margin-bottom:0.25rem}
    select,input,button{width:100%;padding:0.5rem;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:var(--white)}
    .small{font-size:0.85rem;color:var(--muted)}
    .info{margin-top:0.5rem}
    .btn{background:var(--accent);border:none;color:#042028;padding:0.6rem;border-radius:8px;cursor:pointer}
    .edge{stroke:#3b82f6;stroke-width:2;opacity:0.55}
    .mst{stroke:#f59e0b;stroke-width:4;opacity:0.95}
    .node{fill:#06b6d4;stroke:#042028;stroke-width:1}
    .node-label{fill:var(--white);font-size:0.8rem;pointer-events:none}
    .path-edge{stroke:#ef4444;stroke-width:3}
    .legend{display:flex;gap:0.5rem;align-items:center;margin-top:0.5rem}
    .legend span{font-size:0.8rem}
    @media(max-width:800px){.top{flex-direction:column;align-items:flex-start}.map-wrap{height:60vh}}
  </style>
</head>
<body>
  <div class="app">
    <div class="top">
      <div style="flex:1">
        <h1>Drone Delivery — UNILAG Lagos Network</h1>
        <div class="small">Floyd–Warshall for all-pairs shortest paths · Prim's MST for delivery backbone · Exportable route JSON</div>
      </div>
      <div class="card controls">
        <label for="from">From</label>
        <select id="from"></select>
        <label for="to" style="margin-top:0.5rem">To</label>
        <select id="to"></select>
        <div style="display:flex;gap:0.5rem;margin-top:0.5rem">
          <button id="calc" class="btn">Find Shortest Path</button>
          <button id="export" class="btn" style="background:#34d399">Export JSON</button>
        </div>
        <div class="info small card" style="margin-top:0.7rem;background:transparent;padding:0.6rem;border:1px solid rgba(255,255,255,0.03)">
          <div id="result">Select two nodes and click "Find Shortest Path"</div>
          <div class="legend">
            <svg width="18" height="8"><line x1="0" y1="4" x2="18" y2="4" class="edge"/></svg><span>Graph edges</span>
            <svg width="18" height="8"><line x1="0" y1="4" x2="18" y2="4" class="mst"/></svg><span>MST (backbone)</span>
            <svg width="18" height="8"><line x1="0" y1="4" x2="18" y2="4" class="path-edge"/></svg><span>Selected shortest path</span>
          </div>
        </div>
      </div>
    </div>

    <div class="map-wrap card" style="padding:0;overflow:hidden">
      <svg id="canvas" viewBox="0 0 1000 700" preserveAspectRatio="xMidYMid meet"></svg>
    </div>
  </div>

<script>
// === Network definition ===
// Nodes: UNILAG, Akoka, Yaba, Surulere, Ojuelegba, Bariga, Gbagada
const nodes = [
  {id:0,key:'UNILAG', label:'UNILAG', x:180, y:320},
  {id:1,key:'Akoka', label:'Akoka', x:260, y:300},
  {id:2,key:'Yaba', label:'Yaba', x:360, y:260},
  {id:3,key:'Surulere', label:'Surulere', x:520, y:380},
  {id:4,key:'Ojuelegba', label:'Ojuelegba', x:420, y:360},
  {id:5,key:'Bariga', label:'Bariga', x:700, y:160},
  {id:6,key:'Gbagada', label:'Gbagada', x:620, y:240}
];

// Adjacency matrix (undirected). Distances in km (approximate, synthetic) — all <= 15
// We'll use large value for INF
const INF = 1e9;
let adj = Array.from({length:nodes.length},()=>Array(nodes.length).fill(INF));
for(let i=0;i<nodes.length;i++) adj[i][i]=0;
// Define edges (symmetric)
function addEdge(a,b,d){adj[a][b]=d;adj[b][a]=d}
addEdge(0,1,0.8);   // UNILAG - Akoka ~0.8 km
addEdge(0,2,3.5);   // UNILAG - Yaba ~3.5 km
addEdge(1,2,2.0);   // Akoka - Yaba ~2 km
addEdge(2,4,2.1);   // Yaba - Ojuelegba ~2.1 km
addEdge(4,3,2.0);   // Ojuelegba - Surulere ~2 km
addEdge(2,3,3.2);   // Yaba - Surulere ~3.2 km
addEdge(3,6,5.0);   // Surulere - Gbagada ~5 km
addEdge(6,5,3.5);   // Gbagada - Bariga ~3.5 km
addEdge(0,6,7.5);   // UNILAG - Gbagada ~7.5 km
addEdge(4,6,4.0);   // Ojuelegba - Gbagada ~4 km
addEdge(5,6,3.5);   // Bariga - Gbagada duplicated ok
// ensure all pairs have some path < INF in this small network

// === Floyd-Warshall in JS with path reconstruction ===
function floydWarshall(matrix){
  const n = matrix.length;
  const dist = Array.from({length:n},(_,i)=>matrix[i].slice());
  const next = Array.from({length:n},()=>Array(n).fill(-1));
  for(let i=0;i<n;i++){
    for(let j=0;j<n;j++){
      if(matrix[i][j] < INF && i!==j) next[i][j]=j;
    }
  }
  for(let k=0;k<n;k++){
    for(let i=0;i<n;i++){
      for(let j=0;j<n;j++){
        if(dist[i][k] + dist[k][j] < dist[i][j]){
          dist[i][j] = dist[i][k] + dist[k][j];
          next[i][j] = next[i][k];
        }
      }
    }
  }
  return {dist,next};
}

function reconstructPath(next,u,v){
  if(next[u][v]===-1) return [];
  const path = [u];
  while(u!==v){
    u = next[u][v];
    path.push(u);
  }
  return path;
}

const fw = floydWarshall(adj);

// === Prim's MST (to draw backbone) ===
function primMST(matrix){
  const n = matrix.length;
  const inMST = Array(n).fill(false);
  const key = Array(n).fill(INF);
  const parent = Array(n).fill(-1);
  key[0]=0;
  for(let count=0; count<n-1; count++){
    let u=-1; let min=INF;
    for(let v=0;v<n;v++) if(!inMST[v] && key[v]<min){min=key[v];u=v}
    if(u===-1) break;
    inMST[u]=true;
    for(let v=0;v<n;v++){
      if(matrix[u][v] < INF && !inMST[v] && matrix[u][v] < key[v]){
        key[v]=matrix[u][v]; parent[v]=u;
      }
    }
  }
  const edges = [];
  for(let v=1;v<n;v++) if(parent[v]!==-1) edges.push([parent[v],v,matrix[parent[v]][v]]);
  return edges;
}

const mstEdges = primMST(adj);

// === Drawing ===
const svg = document.getElementById('canvas');
function clearSVG(){while(svg.firstChild) svg.removeChild(svg.firstChild)}
function draw(){
  clearSVG();
  // Draw all edges
  for(let i=0;i<nodes.length;i++){
    for(let j=i+1;j<nodes.length;j++){
      if(adj[i][j] < INF){
        const a = nodes[i], b = nodes[j];
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1',a.x); line.setAttribute('y1',a.y);
        line.setAttribute('x2',b.x); line.setAttribute('y2',b.y);
        line.setAttribute('class','edge');
        svg.appendChild(line);
        // Distance label (midpoint)
        const mx = (a.x+b.x)/2, my=(a.y+b.y)/2;
        const t = document.createElementNS('http://www.w3.org/2000/svg','text');
        t.setAttribute('x',mx); t.setAttribute('y',my-6); t.setAttribute('class','node-label');
        t.textContent = (Math.round(adj[i][j]*10)/10) + ' km';
        svg.appendChild(t);
      }
    }
  }
  // Draw MST edges on top
  for(const e of mstEdges){
    const a=nodes[e[0]], b=nodes[e[1]];
    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('x1',a.x); line.setAttribute('y1',a.y);
    line.setAttribute('x2',b.x); line.setAttribute('y2',b.y);
    line.setAttribute('class','mst');
    svg.appendChild(line);
  }
  // Draw nodes
  for(const n of nodes){
    const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
    c.setAttribute('cx',n.x); c.setAttribute('cy',n.y); c.setAttribute('r',10);
    c.setAttribute('class','node');
    svg.appendChild(c);
    const lbl = document.createElementNS('http://www.w3.org/2000/svg','text');
    lbl.setAttribute('x',n.x+14); lbl.setAttribute('y',n.y+6); lbl.setAttribute('class','node-label');
    lbl.textContent = n.label;
    svg.appendChild(lbl);
  }
}

// initial draw
draw();

// populate selects
const fromSel = document.getElementById('from');
const toSel = document.getElementById('to');
for(const n of nodes){
  const o1 = document.createElement('option'); o1.value=n.id; o1.textContent=n.label; fromSel.appendChild(o1);
  const o2 = document.createElement('option'); o2.value=n.id; o2.textContent=n.label; toSel.appendChild(o2);
}
fromSel.value = 0; toSel.value = 3; // default UNILAG -> Surulere

// helper to highlight path
let currentPathElements = [];
function clearPathHighlight(){ for(const el of currentPathElements) el.remove(); currentPathElements = []; }

function highlightPath(path){
  clearPathHighlight();
  if(path.length<2) return;
  for(let i=0;i<path.length-1;i++){
    const a = nodes[path[i]], b = nodes[path[i+1]];
    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('x1',a.x); line.setAttribute('y1',a.y);
    line.setAttribute('x2',b.x); line.setAttribute('y2',b.y);
    line.setAttribute('class','path-edge');
    svg.appendChild(line); currentPathElements.push(line);
  }
  // highlight nodes along path with larger circle
  for(const idx of path){
    const n = nodes[idx];
    const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
    c.setAttribute('cx',n.x); c.setAttribute('cy',n.y); c.setAttribute('r',14);
    c.setAttribute('fill','none'); c.setAttribute('stroke','#ef4444'); c.setAttribute('stroke-width','2');
    svg.appendChild(c); currentPathElements.push(c);
  }
}

// wire up button
document.getElementById('calc').addEventListener('click',()=>{
  const u = parseInt(fromSel.value), v = parseInt(toSel.value);
  const dist = fw.dist[u][v];
  const resDiv = document.getElementById('result');
  if(dist>=INF){ resDiv.textContent = 'No path found between selected nodes'; clearPathHighlight(); return; }
  const path = reconstructPath(fw.next,u,v);
  const names = path.map(i=>nodes[i].label).join(' → ');
  resDiv.innerHTML = `<strong>Path:</strong> ${names} <br><strong>Total distance:</strong> ${Math.round(dist*100)/100} km`;
  highlightPath(path);
});

// export to JSON
document.getElementById('export').addEventListener('click',()=>{
  const u = parseInt(fromSel.value), v = parseInt(toSel.value);
  const dist = fw.dist[u][v];
  if(dist>=INF){ alert('No path exists to export'); return; }
  const path = reconstructPath(fw.next,u,v);
  const out = {
    from: nodes[u].label,
    to: nodes[v].label,
    path: path.map(i=>nodes[i].label),
    distance_km: Math.round(dist*100)/100,
    timestamp: new Date().toISOString()
  };
  const blob = new Blob([JSON.stringify(out,null,2)],{type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download = `route_${nodes[u].label}_to_${nodes[v].label}.json`; a.click();
  URL.revokeObjectURL(url);
});

</script>


</body>
</html>
